const std = @import("std");

const gen =
    \\debug.TIMED_BLOCK(...);
    \\// AUTOGENERATED ----------------------------------------------------------
    \\const blk#counter = debug.TIMED_BLOCK__impl(#counter, @src()).Init(...);
    \\defer blk#counter.End()
    \\// AUTOGENERATED ----------------------------------------------------------
;

const tag = "// AUTOGENERATED";
const call_site = "debug.TIMED_BLOCK__impl("; // should be "debug.TIMED_BLOCK("
const counter_site = "pub fn __COUNTER__() comptime_int";

/// No. of lines the debug imports are required to be within, from the top.
const LINES_SEARCHED_FOR_DEBUG_IMPORT = 2;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer {
        _ = gpa.detectLeaks();
    }

    var counter: u32 = 0;

    if (try processDir(allocator, "./", &counter)) {
        std.debug.print("Processed {} TIMED_BLOCK()s\n", .{counter});
    }
}

fn processDir(allocator: std.mem.Allocator, dir_path: []const u8, counter: *u32) !bool {
    var found = false;
    var dir = try std.fs.cwd().openDir(dir_path, .{ .iterate = true });
    defer dir.close();

    var iter = dir.iterate();

    while (try iter.next()) |entry| {
        switch (entry.kind) {
            .file => {
                if (!std.mem.endsWith(u8, entry.name, ".zig")) {
                    continue;
                } else {
                    var file = try std.fs.cwd().openFile(entry.name, .{ .mode = .read_write });
                    defer file.close();

                    for (0..LINES_SEARCHED_FOR_DEBUG_IMPORT) |_| {
                        if (try file.reader().readUntilDelimiterOrEofAlloc(allocator, '\n', 1000)) |line| {
                            defer allocator.free(line);
                            if (std.mem.indexOf(u8, line, "@import(\"debug\");")) |_| {
                                found = true;
                                const file_size = try file.getEndPos();

                                const buffer = try allocator.alloc(u8, file_size);
                                defer allocator.free(buffer);

                                _ = try file.readAll(buffer);

                                if (try processFile(allocator, entry.name, buffer, counter)) |result| {
                                    defer allocator.free(result.content);

                                    const file_name = try std.mem.concat(allocator, u8, &.{ entry.name, "_e" });
                                    defer allocator.free(file_name);

                                    const dest = try std.fs.cwd().createFile(file_name, .{ .truncate = true });
                                    defer dest.close();

                                    try dest.writeAll(result.content);
                                }

                                break;
                            }
                        }
                    }
                }
            },
            else => continue,
        }
    }

    return found;
}

const process_file_result = struct {
    name: []const u8 = "",
    pos: usize = 0,
    content: []const u8 = "",
};

fn processFile(allocator: std.mem.Allocator, name: []const u8, buffer: []const u8, counter: *u32) !?process_file_result {
    var result: process_file_result = .{};

    var out_buffer = std.ArrayList(u8).init(allocator);
    defer out_buffer.deinit();

    var found_call = false;

    var reader = std.io.fixedBufferStream(buffer);

    while (try reader.reader().readUntilDelimiterOrEofAlloc(allocator, '\n', 1000)) |line| {
        defer allocator.free(line);

        if (std.mem.indexOf(u8, line, call_site)) |_| {
            found_call = true;
            std.debug.print("{s}:{} Found at {s}\n", .{ name, counter.*, line });
            counter.* += 1;
        }

        try out_buffer.appendSlice(line);
        try out_buffer.append('\n');
    }

    if (!found_call) return null;

    result.content = try out_buffer.toOwnedSlice();
    return result;
}

fn fatal(comptime format: []const u8, args: anytype) noreturn {
    std.debug.print(format, args);
    std.process.exit(1);
}

test "t" {
    try std.testing.expectEqual(1, 1);
}
