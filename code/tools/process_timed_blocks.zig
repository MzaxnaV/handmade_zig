const std = @import("std");

const gen =
    \\
    \\{s}// AUTOGENERATED ----------------------------------------------------------
    \\{s}const __t_blk__{} = debug.TIMED_BLOCK__impl({}, @src()).Init({s}
    \\{s}defer __t_blk__{}.End();
    \\{s}// AUTOGENERATED ----------------------------------------------------------
;

const tag = "AUTOGENERATED";
const call_site = "debug.TIMED_BLOCK(";
const counter_site = "pub fn __COUNTER__() comptime_int";

/// No. of lines the debug imports are required to be within, from the top.
const LINES_SEARCHED_FOR_DEBUG_IMPORT = 2;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer {
        _ = gpa.detectLeaks();
    }

    var counter: u32 = 0;

    if (try processDir(allocator, "./", &counter)) {
        std.debug.print("Processed {} TIMED_BLOCK()s\n", .{counter});
    }
}

fn processDir(allocator: std.mem.Allocator, dir_path: []const u8, counter: *u32) !bool {
    var found = false;
    var dir = try std.fs.cwd().openDir(dir_path, .{ .iterate = true });
    defer dir.close();

    var iter = dir.iterate();

    while (try iter.next()) |entry| {
        switch (entry.kind) {
            .file => {
                if (!std.mem.endsWith(u8, entry.name, ".zig")) {
                    continue;
                } else {
                    var file = try std.fs.cwd().openFile(entry.name, .{ .mode = .read_write });
                    defer file.close();

                    for (0..LINES_SEARCHED_FOR_DEBUG_IMPORT) |_| {
                        if (try file.reader().readUntilDelimiterOrEofAlloc(allocator, '\n', 1000)) |line| {
                            defer allocator.free(line);
                            if (std.mem.indexOf(u8, line, "@import(\"debug\");")) |_| {
                                found = true;

                                try file.seekTo(0);

                                const file_size = try file.getEndPos();

                                const buffer = try allocator.alloc(u8, file_size);
                                defer allocator.free(buffer);

                                _ = try file.readAll(buffer);

                                if (try processFile(allocator, entry.name, buffer, counter)) |result| {
                                    defer allocator.free(result.content);

                                    // Truncate the file and write the modified content
                                    try file.seekTo(0);
                                    try file.setEndPos(0);
                                    try file.writeAll(result.content);
                                }

                                break;
                            }
                        }
                    }
                }
            },
            else => continue,
        }
    }

    return found;
}

const process_file_result = struct {
    name: []const u8 = "",
    pos: usize = 0,
    content: []const u8 = "",
};

fn processFile(allocator: std.mem.Allocator, name: []const u8, buffer: []const u8, counter: *u32) !?process_file_result {
    var result: process_file_result = .{};

    var out_buffer = std.ArrayList(u8).init(allocator);
    defer out_buffer.deinit();

    var found_call = false;

    var reader = std.io.fixedBufferStream(buffer);

    var tag_count: u32 = 0;

    while (try reader.reader().readUntilDelimiterOrEofAlloc(allocator, '\n', 1000)) |line| {
        defer allocator.free(line);

        if (std.mem.indexOf(u8, line, tag)) |_| {
            // std.debug.print("Found tag, skipping.\n", .{});
            tag_count = (tag_count + 1) % 2;
            continue;
        }

        if (tag_count == 0) {
            if (std.mem.indexOf(u8, line, call_site)) |pos| {
                found_call = true;

                const indent = line[0..pos];
                const argument = line[pos + call_site.len ..];

                const gen_blk = try std.fmt.allocPrint(allocator, gen, .{ indent, indent, counter.*, counter.*, argument, indent, counter.*, indent });
                defer allocator.free(gen_blk);

                std.debug.print("Overwriting at file, {s}:\n {}: {s}\n", .{ name, counter.*, line });

                counter.* += 1;

                try out_buffer.appendSlice(line);
                try out_buffer.appendSlice(gen_blk);
                try out_buffer.append('\n');
            } else {
                try out_buffer.appendSlice(line);
                try out_buffer.append('\n');
            }
        } else {
            // std.debug.print("Skipping.\n", .{});
            continue;
        }
    }

    if (!found_call) return null;

    result.content = try out_buffer.toOwnedSlice();
    return result;
}
