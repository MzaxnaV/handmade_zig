const std = @import("std");
const config = @import("config");

// TODO (Manav): improve code and optimize it.

const timed_fn_gen =
    \\
    \\{s}// AUTOGENERATED ----------------------------------------------------------
    \\{s}var __t_blk__{} = debug.TIMED_FUNCTION__impl({}, @src()).Init({s}
    \\{s}defer __t_blk__{}.End();
    \\{s}// AUTOGENERATED ----------------------------------------------------------
;

const begin_blk_gen =
    \\
    \\{s}// AUTOGENERATED ----------------------------------------------------------
    \\{s}platform.BEGIN_BLOCK__impl({}, @src(), {s}
    \\{s}// AUTOGENERATED ----------------------------------------------------------
;

const end_blk_gen =
    \\
    \\{s}// AUTOGENERATED ----------------------------------------------------------
    \\{s}platform.END_BLOCK__impl({}, {s}
    \\{s}// AUTOGENERATED ----------------------------------------------------------
;

const frame_marker_gen =
    \\
    \\{s}// AUTOGENERATED ----------------------------------------------------------
    \\{s}platform.FRAME_MARKER__impl({}, @src(), {s}
    \\{s}// AUTOGENERATED ----------------------------------------------------------
;

const timed_blk_gen =
    \\
    \\{s}// AUTOGENERATED ----------------------------------------------------------
    \\{s}var __t_blk__{} = debug.TIMED_BLOCK__impl({}, @src()).Init({s}
    \\{s}defer __t_blk__{}.End();
    \\{s}// AUTOGENERATED ----------------------------------------------------------
;

const counter_gen =
    \\
    \\{s}// AUTOGENERATED ----------------------------------------------------------
    \\{s}{{
    \\{s}    return {};
    \\{s}}}
    \\{s}// AUTOGENERATED ----------------------------------------------------------
;

const tag = "AUTOGENERATED";

const timed_fn_call_site = "debug.TIMED_FUNCTION(";
const begin_blk_call_site = "platform.BEGIN_BLOCK(";
const end_blk_call_site = "platform.END_BLOCK(";
const frame_marker_call_site = "platform.FRAME_MARKER(";
const timed_blk_call_site = "debug.TIMED_BLOCK(";

const counter_site = "pub inline fn __COUNTER__() comptime_int";

/// No. of lines the debug imports are required to be within, from the top.
const LINES_SEARCHED_FOR_DEBUG_IMPORT = 2;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer {
        _ = gpa.detectLeaks();
    }

    var counter: u32 = 0;

    // TODO (Manav): this is ugly
    var file = try std.fs.cwd().openFile("./../win32_handmade.zig", .{ .mode = .read_write });
    defer file.close();

    const file_size = try file.getEndPos();

    const buffer = try allocator.alloc(u8, file_size);
    defer allocator.free(buffer);

    _ = try file.readAll(buffer);

    if (try processFile(allocator, "win32_handmade.zig", buffer, &counter)) |result| {
        defer allocator.free(result.content);

        // Truncate the file and write the modified content
        try file.seekTo(0);
        try file.setEndPos(0);
        try file.writeAll(result.content);
    }

    if (try processDir(allocator, "./", &counter)) {
        std.debug.print("Processed TIMED_BLOCK()s: {}\n", .{counter});
    }

    var debug_file = try std.fs.cwd().openFile("./handmade_debug.zig", .{ .mode = .read_write });
    defer debug_file.close();

    try processDebug(allocator, &debug_file, counter);
}

fn processDir(allocator: std.mem.Allocator, dir_path: []const u8, counter: *u32) !bool {
    var found = false;
    var dir = try std.fs.cwd().openDir(dir_path, .{ .iterate = true });
    defer dir.close();

    var iter = dir.iterate();

    while (try iter.next()) |entry| {
        switch (entry.kind) {
            .file => {
                if (!std.mem.endsWith(u8, entry.name, ".zig")) {
                    continue;
                } else {
                    var file = try std.fs.cwd().openFile(entry.name, .{ .mode = .read_write });
                    defer file.close();

                    for (0..LINES_SEARCHED_FOR_DEBUG_IMPORT) |_| {
                        if (try file.reader().readUntilDelimiterOrEofAlloc(allocator, '\n', 1000)) |line| {
                            defer allocator.free(line);
                            if (std.mem.indexOf(u8, line, "const debug = @import(")) |_| {
                                found = true;

                                try file.seekTo(0);

                                const file_size = try file.getEndPos();

                                const buffer = try allocator.alloc(u8, file_size);
                                defer allocator.free(buffer);

                                _ = try file.readAll(buffer);

                                if (try processFile(allocator, entry.name, buffer, counter)) |result| {
                                    defer allocator.free(result.content);

                                    // Truncate the file and write the modified content
                                    try file.seekTo(0);
                                    try file.setEndPos(0);
                                    try file.writeAll(result.content);
                                }

                                break;
                            }
                        }
                    }
                }
            },
            else => continue,
        }
    }

    return found;
}

const process_file_result = struct {
    name: []const u8 = "",
    pos: usize = 0,
    content: []const u8 = "",
};

fn processFile(allocator: std.mem.Allocator, _: []const u8, buffer: []const u8, counter: *u32) !?process_file_result {
    var result: process_file_result = .{};

    var out_buffer = std.ArrayList(u8).init(allocator);
    defer out_buffer.deinit();

    var found_call = false;

    var reader = std.io.fixedBufferStream(buffer);

    var tag_count: u32 = 0;

    while (try reader.reader().readUntilDelimiterOrEofAlloc(allocator, '\n', 1000)) |line| {
        defer allocator.free(line);

        if (std.mem.indexOf(u8, line, tag)) |_| {
            tag_count = (tag_count + 1) % 2;

            continue;
        }

        if (tag_count == 0) {
            // TODO (Manav): this is ugly
            if (std.mem.indexOf(u8, line, timed_fn_call_site)) |pos| {
                found_call = true;

                const indent = line[0..pos];
                const argument = line[pos + timed_fn_call_site.len ..];

                const gen_blk = try std.fmt.allocPrint(allocator, timed_fn_gen, .{ indent, indent, counter.*, counter.*, argument, indent, counter.*, indent });
                defer allocator.free(gen_blk);

                // std.debug.print("Overwriting line:\n{s}\nwith:\n{s}\n\n", .{ line, gen_blk });

                counter.* += 1;

                try out_buffer.appendSlice(line);
                if (config.PROFILE) {
                    try out_buffer.appendSlice(gen_blk);
                }
                try out_buffer.append('\n');
            } else if (std.mem.indexOf(u8, line, timed_blk_call_site)) |pos| {
                found_call = true;

                const indent = line[0..pos];
                const argument = line[pos + timed_blk_call_site.len ..];

                const gen_blk = try std.fmt.allocPrint(allocator, timed_blk_gen, .{ indent, indent, counter.*, counter.*, argument, indent, counter.*, indent });
                defer allocator.free(gen_blk);

                // std.debug.print("Overwriting line:\n{s}\nwith:\n{s}\n\n", .{ line, gen_blk });

                counter.* += 1;

                try out_buffer.appendSlice(line);
                if (config.PROFILE) {
                    try out_buffer.appendSlice(gen_blk);
                }
                try out_buffer.append('\n');
            } else if (std.mem.indexOf(u8, line, frame_marker_call_site)) |pos| {
                found_call = true;

                const indent = line[0..pos];
                const argument = line[pos + frame_marker_call_site.len ..];

                const gen_blk = try std.fmt.allocPrint(allocator, frame_marker_gen, .{ indent, indent, counter.*, argument, indent });
                defer allocator.free(gen_blk);

                // std.debug.print("Overwriting line:\n{s}\nwith:\n{s}\n\n", .{ line, gen_blk });

                counter.* += 1;

                try out_buffer.appendSlice(line);
                if (config.PROFILE) {
                    try out_buffer.appendSlice(gen_blk);
                }
                try out_buffer.append('\n');
            } else if (std.mem.indexOf(u8, line, begin_blk_call_site)) |pos| {
                found_call = true;

                const indent = line[0..pos];
                const argument = line[pos + begin_blk_call_site.len ..];

                const gen_blk = try std.fmt.allocPrint(allocator, begin_blk_gen, .{ indent, indent, counter.*, argument, indent });
                defer allocator.free(gen_blk);

                // std.debug.print("Overwriting line:\n{s}\nwith:\n{s}\n\n", .{ line, gen_blk });

                try out_buffer.appendSlice(line);
                if (config.PROFILE) {
                    try out_buffer.appendSlice(gen_blk);
                }
                try out_buffer.append('\n');
            } else if (std.mem.indexOf(u8, line, end_blk_call_site)) |pos| {
                found_call = true;

                const indent = line[0..pos];
                const argument = line[pos + end_blk_call_site.len ..];

                const gen_blk = try std.fmt.allocPrint(allocator, end_blk_gen, .{ indent, indent, counter.*, argument, indent });
                defer allocator.free(gen_blk);

                // std.debug.print("Overwriting line:\n{s}\nwith:\n{s}\n\n", .{ line, gen_blk });

                counter.* += 1;

                try out_buffer.appendSlice(line);
                if (config.PROFILE) {
                    try out_buffer.appendSlice(gen_blk);
                }
                try out_buffer.append('\n');
            } else {
                try out_buffer.appendSlice(line);
                try out_buffer.append('\n');
            }
        } else {
            // std.debug.print("Skipping.\n", .{});

            continue;
        }
    }

    if (!found_call) return null;

    result.content = try out_buffer.toOwnedSlice();
    return result;
}

fn processDebug(allocator: std.mem.Allocator, file: *std.fs.File, counter: u32) !void {
    const file_size = try file.getEndPos();

    const buffer = try allocator.alloc(u8, file_size);
    defer allocator.free(buffer);

    _ = try file.readAll(buffer);

    var out_buffer = std.ArrayList(u8).init(allocator);
    defer out_buffer.deinit();

    var found_call = false;

    var reader = std.io.fixedBufferStream(buffer);

    var tag_count: u32 = 0;

    while (try reader.reader().readUntilDelimiterOrEofAlloc(allocator, '\n', 1000)) |line| {
        defer allocator.free(line);

        if (std.mem.indexOf(u8, line, tag)) |_| {
            tag_count = (tag_count + 1) % 2;

            continue;
        }

        if (tag_count == 0) {
            if (std.mem.indexOf(u8, line, counter_site)) |pos| {
                found_call = true;

                const indent = line[0..pos];

                const gen_blk = try std.fmt.allocPrint(allocator, counter_gen, .{ indent, indent, indent, if (config.PROFILE) counter else 0, indent, indent });
                defer allocator.free(gen_blk);

                // std.debug.print("Overwriting line:\n{s}\nwith:\n{s}\n\n", .{ line, gen_blk });

                try out_buffer.appendSlice(line);
                try out_buffer.appendSlice(gen_blk);

                try out_buffer.append('\n');
            } else {
                try out_buffer.appendSlice(line);
                try out_buffer.append('\n');
            }
        } else {
            // std.debug.print("Skipping.\n", .{});

            continue;
        }
    }

    if (!found_call) return;

    const file_contents = try out_buffer.toOwnedSlice();
    defer allocator.free(file_contents);

    try file.seekTo(0);
    try file.setEndPos(0);
    try file.writeAll(file_contents);
}
