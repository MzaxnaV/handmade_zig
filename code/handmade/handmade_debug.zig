const platform = @import("handmade_platform");
const hi = platform.handmade_internal;

const SourceLocation = @import("std").builtin.SourceLocation;

pub const debug_record = struct {};

/// NOTE (Manav): We don't need two sets of theses because of how `TIMED_BLOCK()` works
pub const debugRecords: []debug_record = [1]debug_record{.{}} ** __COUNTER__();

/// The function at call site will be replaced, using a preprocesing tool, with
/// ```
/// debug.TIMED_BLOCK();
/// // AUTOGENERATED ----------------------------------------------------------
/// const blk#counter = debug.TIMED_BLOCK__impl(#counter, @src()){};
/// defer blk#counter.End()
/// // AUTOGENERATED ----------------------------------------------------------
/// ```
/// where #counter will be generated based on `TIMED_BLOCK` call sites
pub fn TIMED_BLOCK() void {}

/// The function definition is replaced with
/// ```
/// // AUTOGENERATED ----------------------------------------------------------
/// {
///     return #counter;
/// }
/// // AUTOGENERATED ----------------------------------------------------------
/// ```
/// where #counter is the total no. of TIMED_BLOCK callsites.
pub fn __COUNTER__() comptime_int
// AUTOGENERATED ----------------------------------------------------------
{
    return 2; // NOTE (Manav): for now hardcode this
}
// AUTOGENERATED ----------------------------------------------------------

/// It relies on `__counter__` is to be supplied at build time using a preprocessing tool,
/// called everytime lib is built. For now use this with hardcoded `__counter__` values until we have one
// NOTE (Manav): zig (0.13) by design, doesn't allow for a way to have a global comptime counter and we don't have unity build.
pub fn TIMED_BLOCK__impl(comptime source: SourceLocation, comptime __counter__: usize) type {
    return struct {
        const internal = @import("std").fmt.comptimePrint();
        const Self = @This();

        pub inline fn Init() Self {
            return Self{
                .id = __counter__,
                // .startCyleCount = hi.__rdtsc(),
            };
        }

        pub inline fn End(self: Self) void {
            @import("std").debug.print("ID: {}, filename: {s}\n", .{ self.id, source.file });

            // if (hi.debugGlobalMemory) |m| {
            //     m.counters[self.id].cycleCount +%= hi.__rdtsc() -% self.startCycleCount;
            //     m.counters[self.id].hitCount +%= 1;
            // }
        }

        id: u32 = __counter__,
        startCycleCount: u64 = 0,
    };
}
